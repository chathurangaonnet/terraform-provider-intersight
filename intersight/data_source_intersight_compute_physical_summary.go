package intersight

import (
	"encoding/json"
	"fmt"
	"log"
	"reflect"

	models "github.com/cisco-intersight/terraform-provider-intersight/intersight_gosdk"
	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
)

func dataSourceComputePhysicalSummary() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceComputePhysicalSummaryRead,
		Schema: map[string]*schema.Schema{
			"admin_power_state": {
				Description: "Desired power state of the server.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"asset_tag": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"available_memory": {
				Description: "The actual amount of memory currently available to the server.",
				Type:        schema.TypeInt,
				Optional:    true,
				Computed:    true,
			},
			"chassis_id": {
				Description: "The id of the chassis that the blade is located in.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"class_id": {
				Description: "The concrete type of this complex type. Its value must be the same as the 'objectType' property.\nThe OpenAPI document references this property as a discriminator value.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"cpu_capacity": {
				Description: "CPU Capacity = Number of CPU Sockets x Enabled Cores x Speed (GHz).",
				Type:        schema.TypeFloat,
				Optional:    true,
				Computed:    true,
			},
			"device_mo_id": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"dn": {
				Description: "The Distinguished Name unambiguously identifies an object in the system.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"fault_summary": {
				Type:     schema.TypeInt,
				Optional: true,
				Computed: true,
			},
			"firmware": {
				Description: "The firmware version of the Cisco Integrated Management Controller (CIMC) for this server.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"ipv4_address": {
				Description: "The IPv4 address configured on the management interface of the Integrated Management Controller.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"kvm_ip_addresses": {
				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"address": {
							Type:     schema.TypeString,
							Optional: true,
							Computed: true,
						},
						"category": {
							Type:     schema.TypeString,
							Optional: true,
							Computed: true,
						},
						"class_id": {
							Description: "The concrete type of this complex type. Its value must be the same as the 'objectType' property.\nThe OpenAPI document references this property as a discriminator value.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
						"default_gateway": {
							Description: "Gateway address of the KVM IP address.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
						"dn": {
							Type:     schema.TypeString,
							Optional: true,
							Computed: true,
						},
						"http_port": {
							Type:     schema.TypeInt,
							Optional: true,
							Computed: true,
						},
						"https_port": {
							Type:     schema.TypeInt,
							Optional: true,
							Computed: true,
						},
						"kvm_port": {
							Description: "Port number on which the KVM is running.",
							Type:        schema.TypeInt,
							Optional:    true,
							Computed:    true,
						},
						"name": {
							Type:     schema.TypeString,
							Optional: true,
							Computed: true,
						},
						"object_type": {
							Description: "The concrete type of this complex type.\nThe ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the \nObjectType is optional. \nThe type is ambiguous when a managed object contains an array of nested documents, and the documents in the array\nare heterogeneous, i.e. the array can contain nested documents of different types.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
						"subnet": {
							Description: "Subnet of the KVM IP address.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
						"type": {
							Type:     schema.TypeString,
							Optional: true,
							Computed: true,
						},
					},
				},
				Computed: true,
			},
			"memory_speed": {
				Description: "The memory speed, in megahertz.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"mgmt_ip_address": {
				Description: "Management address of the server.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"model": {
				Description: "This field identifies the model of the given component.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"moid": {
				Description: "The unique identifier of this Managed Object instance.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"name": {
				Description: "The name of the UCS Fabric Interconnect cluster or Cisco Integrated Management Controller (CIMC).\nWhen this server is attached to a UCS Fabric Interconnect, the value of this property is the name of the UCS Fabric Interconnect.\nWhen this server configured in standalone mode, the value of this property is the name of the Cisco Integrated Management Controller.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"num_adaptors": {
				Description: "Total number of Adaptors available.",
				Type:        schema.TypeInt,
				Optional:    true,
				Computed:    true,
			},
			"num_cpu_cores": {
				Description: "Total number of CPU cores available.",
				Type:        schema.TypeInt,
				Optional:    true,
				Computed:    true,
			},
			"num_cpu_cores_enabled": {
				Description: "Number of CPU cores enabled.",
				Type:        schema.TypeInt,
				Optional:    true,
				Computed:    true,
			},
			"num_cpus": {
				Description: "Total number of CPU's available.",
				Type:        schema.TypeInt,
				Optional:    true,
				Computed:    true,
			},
			"num_eth_host_interfaces": {
				Description: "Number of Ethernet Host Interfaces.",
				Type:        schema.TypeInt,
				Optional:    true,
				Computed:    true,
			},
			"num_fc_host_interfaces": {
				Description: "Number of Fibre channel Host Interfaces.",
				Type:        schema.TypeInt,
				Optional:    true,
				Computed:    true,
			},
			"num_threads": {
				Description: "Number of threads enabled.",
				Type:        schema.TypeInt,
				Optional:    true,
				Computed:    true,
			},
			"object_type": {
				Description: "The fully-qualified type of this managed object, i.e. the class name.\nThis property is optional. The ObjectType is implied from the URL path.\nIf specified, the value of objectType must match the class name specified in the URL path.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"oper_power_state": {
				Description: "Current power state of the server.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"oper_state": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"operability": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"permission_resources": {
				Description: "An array of relationships to moBaseMo resources.",
				Type:        schema.TypeList,
				Optional:    true,
				Computed:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"class_id": {
							Description: "The concrete type of this complex type. Its value must be the same as the 'objectType' property.\nThe OpenAPI document references this property as a discriminator value.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
						"link": {
							Description: "A URL to an instance of the 'mo.MoRef' class.",
							Type:        schema.TypeString,
							Optional:    true,
						},
						"moid": {
							Description: "The Moid of the referenced REST resource.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
						"object_type": {
							Description: "The concrete type of this complex type.\nThe ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the \nObjectType is optional. \nThe type is ambiguous when a managed object contains an array of nested documents, and the documents in the array\nare heterogeneous, i.e. the array can contain nested documents of different types.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
						"selector": {
							Description: "An OData $filter expression which describes the REST resource to be referenced. This field may\nbe set instead of 'moid' by clients.\n1. If 'moid' is set this field is ignored.\n1. If 'selector' is set and 'moid' is empty/absent from the request, Intersight determines the Moid of the\nresource matching the filter expression and populates it in the MoRef that is part of the object\ninstance being inserted/updated to fulfill the REST request.\nAn error is returned if the filter matches zero or more than one REST resource.\nAn example filter string is: Serial eq '3AA8B7T11'.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
					},
				},
			},
			"platform_type": {
				Description: "Platform type of the device.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"presence": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"registered_device": {
				Description: "A reference to a assetDeviceRegistration resource.\nWhen the $expand query parameter is specified, the referenced resource is returned inline.",
				Type:        schema.TypeList,
				MaxItems:    1,
				Optional:    true,
				Computed:    true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"class_id": {
							Description: "The concrete type of this complex type. Its value must be the same as the 'objectType' property.\nThe OpenAPI document references this property as a discriminator value.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
						"link": {
							Description: "A URL to an instance of the 'mo.MoRef' class.",
							Type:        schema.TypeString,
							Optional:    true,
						},
						"moid": {
							Description: "The Moid of the referenced REST resource.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
						"object_type": {
							Description: "The concrete type of this complex type.\nThe ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the \nObjectType is optional. \nThe type is ambiguous when a managed object contains an array of nested documents, and the documents in the array\nare heterogeneous, i.e. the array can contain nested documents of different types.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
						"selector": {
							Description: "An OData $filter expression which describes the REST resource to be referenced. This field may\nbe set instead of 'moid' by clients.\n1. If 'moid' is set this field is ignored.\n1. If 'selector' is set and 'moid' is empty/absent from the request, Intersight determines the Moid of the\nresource matching the filter expression and populates it in the MoRef that is part of the object\ninstance being inserted/updated to fulfill the REST request.\nAn error is returned if the filter matches zero or more than one REST resource.\nAn example filter string is: Serial eq '3AA8B7T11'.",
							Type:        schema.TypeString,
							Optional:    true,
							Computed:    true,
						},
					},
				},
			},
			"revision": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"rn": {
				Description: "The Relative Name uniquely identifies an object within a given context.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"scaled_mode": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"serial": {
				Description: "This field identifies the serial of the given component.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"server_id": {
				Description: "The server id of the Rack server.",
				Type:        schema.TypeInt,
				Optional:    true,
				Computed:    true,
			},
			"service_profile": {
				Description: "The service profile assigned.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"slot_id": {
				Type:     schema.TypeInt,
				Optional: true,
				Computed: true,
			},
			"source_object_type": {
				Description: "The source object type of this view MO.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
			"tags": {
				Type:     schema.TypeList,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"key": {
							Description: "The string representation of a tag key.",
							Type:        schema.TypeString,
							Optional:    true,
						},
						"value": {
							Description: "The string representation of a tag value.",
							Type:        schema.TypeString,
							Optional:    true,
						},
					},
				},
			},
			"total_memory": {
				Type:     schema.TypeInt,
				Optional: true,
				Computed: true,
			},
			"user_label": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"uuid": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
			},
			"vendor": {
				Description: "This field identifies the vendor of the given component.",
				Type:        schema.TypeString,
				Optional:    true,
				Computed:    true,
			},
		},
	}
}

func dataSourceComputePhysicalSummaryRead(d *schema.ResourceData, meta interface{}) error {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	log.Printf("%v", meta)
	conn := meta.(*Config)
	var o = models.NewComputePhysicalSummary()
	if v, ok := d.GetOk("admin_power_state"); ok {
		x := (v.(string))
		o.SetAdminPowerState(x)
	}
	if v, ok := d.GetOk("asset_tag"); ok {
		x := (v.(string))
		o.SetAssetTag(x)
	}
	if v, ok := d.GetOk("available_memory"); ok {
		x := int64(v.(int))
		o.SetAvailableMemory(x)
	}
	if v, ok := d.GetOk("chassis_id"); ok {
		x := (v.(string))
		o.SetChassisId(x)
	}
	if v, ok := d.GetOk("class_id"); ok {
		x := (v.(string))
		o.SetClassId(x)
	}
	if v, ok := d.GetOk("cpu_capacity"); ok {
		x := v.(float32)
		o.SetCpuCapacity(x)
	}
	if v, ok := d.GetOk("device_mo_id"); ok {
		x := (v.(string))
		o.SetDeviceMoId(x)
	}
	if v, ok := d.GetOk("dn"); ok {
		x := (v.(string))
		o.SetDn(x)
	}
	if v, ok := d.GetOk("fault_summary"); ok {
		x := int64(v.(int))
		o.SetFaultSummary(x)
	}
	if v, ok := d.GetOk("firmware"); ok {
		x := (v.(string))
		o.SetFirmware(x)
	}
	if v, ok := d.GetOk("ipv4_address"); ok {
		x := (v.(string))
		o.SetIpv4Address(x)
	}
	if v, ok := d.GetOk("memory_speed"); ok {
		x := (v.(string))
		o.SetMemorySpeed(x)
	}
	if v, ok := d.GetOk("mgmt_ip_address"); ok {
		x := (v.(string))
		o.SetMgmtIpAddress(x)
	}
	if v, ok := d.GetOk("model"); ok {
		x := (v.(string))
		o.SetModel(x)
	}
	if v, ok := d.GetOk("moid"); ok {
		x := (v.(string))
		o.SetMoid(x)
	}
	if v, ok := d.GetOk("name"); ok {
		x := (v.(string))
		o.SetName(x)
	}
	if v, ok := d.GetOk("num_adaptors"); ok {
		x := int64(v.(int))
		o.SetNumAdaptors(x)
	}
	if v, ok := d.GetOk("num_cpu_cores"); ok {
		x := int64(v.(int))
		o.SetNumCpuCores(x)
	}
	if v, ok := d.GetOk("num_cpu_cores_enabled"); ok {
		x := int64(v.(int))
		o.SetNumCpuCoresEnabled(x)
	}
	if v, ok := d.GetOk("num_cpus"); ok {
		x := int64(v.(int))
		o.SetNumCpus(x)
	}
	if v, ok := d.GetOk("num_eth_host_interfaces"); ok {
		x := int64(v.(int))
		o.SetNumEthHostInterfaces(x)
	}
	if v, ok := d.GetOk("num_fc_host_interfaces"); ok {
		x := int64(v.(int))
		o.SetNumFcHostInterfaces(x)
	}
	if v, ok := d.GetOk("num_threads"); ok {
		x := int64(v.(int))
		o.SetNumThreads(x)
	}
	if v, ok := d.GetOk("object_type"); ok {
		x := (v.(string))
		o.SetObjectType(x)
	}
	if v, ok := d.GetOk("oper_power_state"); ok {
		x := (v.(string))
		o.SetOperPowerState(x)
	}
	if v, ok := d.GetOk("oper_state"); ok {
		x := (v.(string))
		o.SetOperState(x)
	}
	if v, ok := d.GetOk("operability"); ok {
		x := (v.(string))
		o.SetOperability(x)
	}
	if v, ok := d.GetOk("platform_type"); ok {
		x := (v.(string))
		o.SetPlatformType(x)
	}
	if v, ok := d.GetOk("presence"); ok {
		x := (v.(string))
		o.SetPresence(x)
	}
	if v, ok := d.GetOk("revision"); ok {
		x := (v.(string))
		o.SetRevision(x)
	}
	if v, ok := d.GetOk("rn"); ok {
		x := (v.(string))
		o.SetRn(x)
	}
	if v, ok := d.GetOk("scaled_mode"); ok {
		x := (v.(string))
		o.SetScaledMode(x)
	}
	if v, ok := d.GetOk("serial"); ok {
		x := (v.(string))
		o.SetSerial(x)
	}
	if v, ok := d.GetOk("server_id"); ok {
		x := int64(v.(int))
		o.SetServerId(x)
	}
	if v, ok := d.GetOk("service_profile"); ok {
		x := (v.(string))
		o.SetServiceProfile(x)
	}
	if v, ok := d.GetOk("slot_id"); ok {
		x := int64(v.(int))
		o.SetSlotId(x)
	}
	if v, ok := d.GetOk("source_object_type"); ok {
		x := (v.(string))
		o.SetSourceObjectType(x)
	}
	if v, ok := d.GetOk("total_memory"); ok {
		x := int64(v.(int))
		o.SetTotalMemory(x)
	}
	if v, ok := d.GetOk("user_label"); ok {
		x := (v.(string))
		o.SetUserLabel(x)
	}
	if v, ok := d.GetOk("uuid"); ok {
		x := (v.(string))
		o.SetUuid(x)
	}
	if v, ok := d.GetOk("vendor"); ok {
		x := (v.(string))
		o.SetVendor(x)
	}

	data, err := o.MarshalJSON()
	if err != nil {
		return fmt.Errorf("Json Marshalling of data source failed with error : %+v", err)
	}
	result, _, err := conn.ApiClient.ComputeApi.GetComputePhysicalSummaryList(conn.ctx).Filter(getRequestParams(data)).Execute()
	if err != nil {
		return fmt.Errorf("your query returned no results. Please change your search criteria and try again")
	}
	switch reflect.TypeOf(result).Kind() {
	case reflect.Slice:
		r := reflect.ValueOf(result)
		for i := 0; i < r.Len(); i++ {
			var s = models.NewComputePhysicalSummary()
			oo, _ := json.Marshal(r.Index(i).Interface())
			if err = json.Unmarshal(oo, s); err != nil {
				return err
			}
			if err := d.Set("admin_power_state", (s.AdminPowerState)); err != nil {
				return err
			}
			if err := d.Set("asset_tag", (s.AssetTag)); err != nil {
				return err
			}
			if err := d.Set("available_memory", (s.AvailableMemory)); err != nil {
				return err
			}
			if err := d.Set("chassis_id", (s.ChassisId)); err != nil {
				return err
			}
			if err := d.Set("class_id", (s.ClassId)); err != nil {
				return err
			}
			if err := d.Set("cpu_capacity", (s.CpuCapacity)); err != nil {
				return err
			}
			if err := d.Set("device_mo_id", (s.DeviceMoId)); err != nil {
				return err
			}
			if err := d.Set("dn", (s.Dn)); err != nil {
				return err
			}
			if err := d.Set("fault_summary", (s.FaultSummary)); err != nil {
				return err
			}
			if err := d.Set("firmware", (s.Firmware)); err != nil {
				return err
			}
			if err := d.Set("ipv4_address", (s.Ipv4Address)); err != nil {
				return err
			}

			if err := d.Set("kvm_ip_addresses", flattenListComputeIpAddress(s.KvmIpAddresses, d)); err != nil {
				return err
			}
			if err := d.Set("memory_speed", (s.MemorySpeed)); err != nil {
				return err
			}
			if err := d.Set("mgmt_ip_address", (s.MgmtIpAddress)); err != nil {
				return err
			}
			if err := d.Set("model", (s.Model)); err != nil {
				return err
			}
			if err := d.Set("moid", (s.Moid)); err != nil {
				return err
			}
			if err := d.Set("name", (s.Name)); err != nil {
				return err
			}
			if err := d.Set("num_adaptors", (s.NumAdaptors)); err != nil {
				return err
			}
			if err := d.Set("num_cpu_cores", (s.NumCpuCores)); err != nil {
				return err
			}
			if err := d.Set("num_cpu_cores_enabled", (s.NumCpuCoresEnabled)); err != nil {
				return err
			}
			if err := d.Set("num_cpus", (s.NumCpus)); err != nil {
				return err
			}
			if err := d.Set("num_eth_host_interfaces", (s.NumEthHostInterfaces)); err != nil {
				return err
			}
			if err := d.Set("num_fc_host_interfaces", (s.NumFcHostInterfaces)); err != nil {
				return err
			}
			if err := d.Set("num_threads", (s.NumThreads)); err != nil {
				return err
			}
			if err := d.Set("object_type", (s.ObjectType)); err != nil {
				return err
			}
			if err := d.Set("oper_power_state", (s.OperPowerState)); err != nil {
				return err
			}
			if err := d.Set("oper_state", (s.OperState)); err != nil {
				return err
			}
			if err := d.Set("operability", (s.Operability)); err != nil {
				return err
			}

			if err := d.Set("permission_resources", flattenListMoBaseMoRelationship(s.PermissionResources, d)); err != nil {
				return err
			}
			if err := d.Set("platform_type", (s.PlatformType)); err != nil {
				return err
			}
			if err := d.Set("presence", (s.Presence)); err != nil {
				return err
			}

			if err := d.Set("registered_device", flattenMapAssetDeviceRegistrationRelationship(s.RegisteredDevice, d)); err != nil {
				return err
			}
			if err := d.Set("revision", (s.Revision)); err != nil {
				return err
			}
			if err := d.Set("rn", (s.Rn)); err != nil {
				return err
			}
			if err := d.Set("scaled_mode", (s.ScaledMode)); err != nil {
				return err
			}
			if err := d.Set("serial", (s.Serial)); err != nil {
				return err
			}
			if err := d.Set("server_id", (s.ServerId)); err != nil {
				return err
			}
			if err := d.Set("service_profile", (s.ServiceProfile)); err != nil {
				return err
			}
			if err := d.Set("slot_id", (s.SlotId)); err != nil {
				return err
			}
			if err := d.Set("source_object_type", (s.SourceObjectType)); err != nil {
				return err
			}

			if err := d.Set("tags", flattenListMoTag(s.Tags, d)); err != nil {
				return err
			}
			if err := d.Set("total_memory", (s.TotalMemory)); err != nil {
				return err
			}
			if err := d.Set("user_label", (s.UserLabel)); err != nil {
				return err
			}
			if err := d.Set("uuid", (s.Uuid)); err != nil {
				return err
			}
			if err := d.Set("vendor", (s.Vendor)); err != nil {
				return err
			}
			d.SetId(s.GetMoid())
		}
	}
	return nil
}
