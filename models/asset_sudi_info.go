// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AssetSudiInfo Asset:Sudi Info
//
// The SUDI is an X.509v3 certificate, which maintains the product identifier and serial number. The identity is implemented at manufacturing and chained to a publicly identifiable root certificate authority. It can be used as an unchangeable identity for configuration, security, auditing, and management. This strucure contains the SUDI information read from the device's Trust Anchor Module (TAM).
//
// swagger:model assetSudiInfo
type AssetSudiInfo struct {
	AssetSudiInfoAO0P0
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *AssetSudiInfo) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 AssetSudiInfoAO0P0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.AssetSudiInfoAO0P0 = aO0

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m AssetSudiInfo) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(m.AssetSudiInfoAO0P0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this asset sudi info
func (m *AssetSudiInfo) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with AssetSudiInfoAO0P0
	if err := m.AssetSudiInfoAO0P0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *AssetSudiInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetSudiInfo) UnmarshalBinary(b []byte) error {
	var res AssetSudiInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AssetSudiInfoAO0P0 asset sudi info a o0 p0
// swagger:model AssetSudiInfoAO0P0
type AssetSudiInfoAO0P0 struct {

	// The concrete type of this complex type.
	//
	// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
	// ObjectType is optional.
	// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
	// are heterogeneous, i.e. the array can contain nested documents of different types.
	//
	//
	ObjectType string `json:"ObjectType,omitempty"`

	// The device model (PID) extracted from the X.509 SUDI Leaf Certificate.
	//
	Pid string `json:"Pid,omitempty"`

	// The device SerialNumber extracted from the X.509 SUDI Leaf Certiicate.
	//
	SerialNumber string `json:"SerialNumber,omitempty"`

	// The signature is obtained by taking the base64 encoding of the Serial Number + PID + Status, taking the SHA256 hash and then signing with the SUDI X.509 Leaf Certifiate.
	//
	Signature string `json:"Signature,omitempty"`

	// The validation status of the device.
	//
	// Enum: [DeviceStatusUnknown Verified CertificateValidationFailed UnsupportedFirmware UnsupportedHardware DeviceNotResponding]
	Status *string `json:"Status,omitempty"`

	// The X.509 SUDI Leaf Certificate from the Trust Anchor Module. The certificate is serialized in PEM format (Base64 encoded DER certificate).
	//
	SudiCertificate *X509Certificate `json:"SudiCertificate,omitempty"`

	// asset sudi info a o0 p0
	AssetSudiInfoAO0P0 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *AssetSudiInfoAO0P0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// The concrete type of this complex type.
		//
		// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
		// ObjectType is optional.
		// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
		// are heterogeneous, i.e. the array can contain nested documents of different types.
		//
		//
		ObjectType string `json:"ObjectType,omitempty"`

		// The device model (PID) extracted from the X.509 SUDI Leaf Certificate.
		//
		Pid string `json:"Pid,omitempty"`

		// The device SerialNumber extracted from the X.509 SUDI Leaf Certiicate.
		//
		SerialNumber string `json:"SerialNumber,omitempty"`

		// The signature is obtained by taking the base64 encoding of the Serial Number + PID + Status, taking the SHA256 hash and then signing with the SUDI X.509 Leaf Certifiate.
		//
		Signature string `json:"Signature,omitempty"`

		// The validation status of the device.
		//
		// Enum: [DeviceStatusUnknown Verified CertificateValidationFailed UnsupportedFirmware UnsupportedHardware DeviceNotResponding]
		Status *string `json:"Status,omitempty"`

		// The X.509 SUDI Leaf Certificate from the Trust Anchor Module. The certificate is serialized in PEM format (Base64 encoded DER certificate).
		//
		SudiCertificate *X509Certificate `json:"SudiCertificate,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv AssetSudiInfoAO0P0

	rcv.ObjectType = stage1.ObjectType

	rcv.Pid = stage1.Pid

	rcv.SerialNumber = stage1.SerialNumber

	rcv.Signature = stage1.Signature

	rcv.Status = stage1.Status

	rcv.SudiCertificate = stage1.SudiCertificate

	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "ObjectType")

	delete(stage2, "Pid")

	delete(stage2, "SerialNumber")

	delete(stage2, "Signature")

	delete(stage2, "Status")

	delete(stage2, "SudiCertificate")

	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.AssetSudiInfoAO0P0 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m AssetSudiInfoAO0P0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// The concrete type of this complex type.
		//
		// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
		// ObjectType is optional.
		// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
		// are heterogeneous, i.e. the array can contain nested documents of different types.
		//
		//
		ObjectType string `json:"ObjectType,omitempty"`

		// The device model (PID) extracted from the X.509 SUDI Leaf Certificate.
		//
		Pid string `json:"Pid,omitempty"`

		// The device SerialNumber extracted from the X.509 SUDI Leaf Certiicate.
		//
		SerialNumber string `json:"SerialNumber,omitempty"`

		// The signature is obtained by taking the base64 encoding of the Serial Number + PID + Status, taking the SHA256 hash and then signing with the SUDI X.509 Leaf Certifiate.
		//
		Signature string `json:"Signature,omitempty"`

		// The validation status of the device.
		//
		// Enum: [DeviceStatusUnknown Verified CertificateValidationFailed UnsupportedFirmware UnsupportedHardware DeviceNotResponding]
		Status *string `json:"Status,omitempty"`

		// The X.509 SUDI Leaf Certificate from the Trust Anchor Module. The certificate is serialized in PEM format (Base64 encoded DER certificate).
		//
		SudiCertificate *X509Certificate `json:"SudiCertificate,omitempty"`
	}

	stage1.ObjectType = m.ObjectType

	stage1.Pid = m.Pid

	stage1.SerialNumber = m.SerialNumber

	stage1.Signature = m.Signature

	stage1.Status = m.Status

	stage1.SudiCertificate = m.SudiCertificate

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.AssetSudiInfoAO0P0) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.AssetSudiInfoAO0P0)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this asset sudi info a o0 p0
func (m *AssetSudiInfoAO0P0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSudiCertificate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var assetSudiInfoAO0P0TypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DeviceStatusUnknown","Verified","CertificateValidationFailed","UnsupportedFirmware","UnsupportedHardware","DeviceNotResponding"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		assetSudiInfoAO0P0TypeStatusPropEnum = append(assetSudiInfoAO0P0TypeStatusPropEnum, v)
	}
}

const (

	// AssetSudiInfoAO0P0StatusDeviceStatusUnknown captures enum value "DeviceStatusUnknown"
	AssetSudiInfoAO0P0StatusDeviceStatusUnknown string = "DeviceStatusUnknown"

	// AssetSudiInfoAO0P0StatusVerified captures enum value "Verified"
	AssetSudiInfoAO0P0StatusVerified string = "Verified"

	// AssetSudiInfoAO0P0StatusCertificateValidationFailed captures enum value "CertificateValidationFailed"
	AssetSudiInfoAO0P0StatusCertificateValidationFailed string = "CertificateValidationFailed"

	// AssetSudiInfoAO0P0StatusUnsupportedFirmware captures enum value "UnsupportedFirmware"
	AssetSudiInfoAO0P0StatusUnsupportedFirmware string = "UnsupportedFirmware"

	// AssetSudiInfoAO0P0StatusUnsupportedHardware captures enum value "UnsupportedHardware"
	AssetSudiInfoAO0P0StatusUnsupportedHardware string = "UnsupportedHardware"

	// AssetSudiInfoAO0P0StatusDeviceNotResponding captures enum value "DeviceNotResponding"
	AssetSudiInfoAO0P0StatusDeviceNotResponding string = "DeviceNotResponding"
)

// prop value enum
func (m *AssetSudiInfoAO0P0) validateStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, assetSudiInfoAO0P0TypeStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *AssetSudiInfoAO0P0) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("Status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *AssetSudiInfoAO0P0) validateSudiCertificate(formats strfmt.Registry) error {

	if swag.IsZero(m.SudiCertificate) { // not required
		return nil
	}

	if m.SudiCertificate != nil {
		if err := m.SudiCertificate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("SudiCertificate")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AssetSudiInfoAO0P0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetSudiInfoAO0P0) UnmarshalBinary(b []byte) error {
	var res AssetSudiInfoAO0P0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
