// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// ConnectorBaseMessage Connector:Base Message
//
// A base abstract message that handles the common request properties applicable for all the message types.
//
// swagger:model connectorBaseMessage
type ConnectorBaseMessage struct {
	ConnectorBaseMessageAO0P0
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ConnectorBaseMessage) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 ConnectorBaseMessageAO0P0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.ConnectorBaseMessageAO0P0 = aO0

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ConnectorBaseMessage) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(m.ConnectorBaseMessageAO0P0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this connector base message
func (m *ConnectorBaseMessage) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with ConnectorBaseMessageAO0P0
	if err := m.ConnectorBaseMessageAO0P0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ConnectorBaseMessage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConnectorBaseMessage) UnmarshalBinary(b []byte) error {
	var res ConnectorBaseMessage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConnectorBaseMessageAO0P0 connector base message a o0 p0
// swagger:model ConnectorBaseMessageAO0P0
type ConnectorBaseMessageAO0P0 struct {

	// The secure properties that have large text content as value can be encrypted using AES key. In these cases, the AES key needs to be encrypted using the device connector public key and passed as the value for this property.
	// The secure properties that are encrypted using the AES key are mapped against the property name with prefix 'AES' in SecureProperties dictionary.
	//
	EncryptedAesKey string `json:"EncryptedAesKey,omitempty"`

	// The public key that was used to encrypt the values present in SecureProperties dictionary.
	// If the given public key is not same as device connector's public key, an error reponse with appropriate error message is thrown back.
	//
	EncryptionKey string `json:"EncryptionKey,omitempty"`

	// The concrete type of this complex type.
	//
	// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
	// ObjectType is optional.
	// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
	// are heterogeneous, i.e. the array can contain nested documents of different types.
	//
	//
	ObjectType string `json:"ObjectType,omitempty"`

	// A dictionary of encrypted secure values mapped against the secure property name. The values that are encrypted using AES key must be mapped against the secure property name with a 'AES' prefix
	// Device connector expects the message body to be a golang template and the template can use the secure property names as placeholders.
	//
	SecureProperties interface{} `json:"SecureProperties,omitempty"`

	// connector base message a o0 p0
	ConnectorBaseMessageAO0P0 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *ConnectorBaseMessageAO0P0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// The secure properties that have large text content as value can be encrypted using AES key. In these cases, the AES key needs to be encrypted using the device connector public key and passed as the value for this property.
		// The secure properties that are encrypted using the AES key are mapped against the property name with prefix 'AES' in SecureProperties dictionary.
		//
		EncryptedAesKey string `json:"EncryptedAesKey,omitempty"`

		// The public key that was used to encrypt the values present in SecureProperties dictionary.
		// If the given public key is not same as device connector's public key, an error reponse with appropriate error message is thrown back.
		//
		EncryptionKey string `json:"EncryptionKey,omitempty"`

		// The concrete type of this complex type.
		//
		// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
		// ObjectType is optional.
		// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
		// are heterogeneous, i.e. the array can contain nested documents of different types.
		//
		//
		ObjectType string `json:"ObjectType,omitempty"`

		// A dictionary of encrypted secure values mapped against the secure property name. The values that are encrypted using AES key must be mapped against the secure property name with a 'AES' prefix
		// Device connector expects the message body to be a golang template and the template can use the secure property names as placeholders.
		//
		SecureProperties interface{} `json:"SecureProperties,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv ConnectorBaseMessageAO0P0

	rcv.EncryptedAesKey = stage1.EncryptedAesKey

	rcv.EncryptionKey = stage1.EncryptionKey

	rcv.ObjectType = stage1.ObjectType

	rcv.SecureProperties = stage1.SecureProperties

	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "EncryptedAesKey")

	delete(stage2, "EncryptionKey")

	delete(stage2, "ObjectType")

	delete(stage2, "SecureProperties")

	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.ConnectorBaseMessageAO0P0 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m ConnectorBaseMessageAO0P0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// The secure properties that have large text content as value can be encrypted using AES key. In these cases, the AES key needs to be encrypted using the device connector public key and passed as the value for this property.
		// The secure properties that are encrypted using the AES key are mapped against the property name with prefix 'AES' in SecureProperties dictionary.
		//
		EncryptedAesKey string `json:"EncryptedAesKey,omitempty"`

		// The public key that was used to encrypt the values present in SecureProperties dictionary.
		// If the given public key is not same as device connector's public key, an error reponse with appropriate error message is thrown back.
		//
		EncryptionKey string `json:"EncryptionKey,omitempty"`

		// The concrete type of this complex type.
		//
		// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
		// ObjectType is optional.
		// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
		// are heterogeneous, i.e. the array can contain nested documents of different types.
		//
		//
		ObjectType string `json:"ObjectType,omitempty"`

		// A dictionary of encrypted secure values mapped against the secure property name. The values that are encrypted using AES key must be mapped against the secure property name with a 'AES' prefix
		// Device connector expects the message body to be a golang template and the template can use the secure property names as placeholders.
		//
		SecureProperties interface{} `json:"SecureProperties,omitempty"`
	}

	stage1.EncryptedAesKey = m.EncryptedAesKey

	stage1.EncryptionKey = m.EncryptionKey

	stage1.ObjectType = m.ObjectType

	stage1.SecureProperties = m.SecureProperties

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.ConnectorBaseMessageAO0P0) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.ConnectorBaseMessageAO0P0)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this connector base message a o0 p0
func (m *ConnectorBaseMessageAO0P0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConnectorBaseMessageAO0P0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConnectorBaseMessageAO0P0) UnmarshalBinary(b []byte) error {
	var res ConnectorBaseMessageAO0P0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
