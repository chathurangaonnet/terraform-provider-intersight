// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// IamPermissionReference Iam:Permission Reference
//
// Users can log in through the base URL (https://intersight.com) or account-specific URLs. When the Intersight user logs in through the base URL, Intersight identifies the accounts and permissions within each account which the user has access to. In case multiple permissions are identified, the user and session objects are created in the onboarding-user account, and the session object is updated with account and permission information. Intersight GUI uses this information to show available accounts and permissions for the user to select. PermissionReference type is used to store permission information of an account.
//
// swagger:model iamPermissionReference
type IamPermissionReference struct {
	IamPermissionReferenceAO0P0
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *IamPermissionReference) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 IamPermissionReferenceAO0P0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.IamPermissionReferenceAO0P0 = aO0

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m IamPermissionReference) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(m.IamPermissionReferenceAO0P0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this iam permission reference
func (m *IamPermissionReference) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with IamPermissionReferenceAO0P0
	if err := m.IamPermissionReferenceAO0P0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *IamPermissionReference) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IamPermissionReference) UnmarshalBinary(b []byte) error {
	var res IamPermissionReference
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// IamPermissionReferenceAO0P0 iam permission reference a o0 p0
// swagger:model IamPermissionReferenceAO0P0
type IamPermissionReferenceAO0P0 struct {

	// The concrete type of this complex type.
	//
	// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
	// ObjectType is optional.
	// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
	// are heterogeneous, i.e. the array can contain nested documents of different types.
	//
	//
	ObjectType string `json:"ObjectType,omitempty"`

	// MOID of the permission which user has access to.
	//
	// Read Only: true
	PermissionIdentifier string `json:"PermissionIdentifier,omitempty"`

	// Name of the permission which user has access to.
	//
	// Read Only: true
	PermissionName string `json:"PermissionName,omitempty"`

	// iam permission reference a o0 p0
	IamPermissionReferenceAO0P0 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *IamPermissionReferenceAO0P0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// The concrete type of this complex type.
		//
		// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
		// ObjectType is optional.
		// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
		// are heterogeneous, i.e. the array can contain nested documents of different types.
		//
		//
		ObjectType string `json:"ObjectType,omitempty"`

		// MOID of the permission which user has access to.
		//
		// Read Only: true
		PermissionIdentifier string `json:"PermissionIdentifier,omitempty"`

		// Name of the permission which user has access to.
		//
		// Read Only: true
		PermissionName string `json:"PermissionName,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv IamPermissionReferenceAO0P0

	rcv.ObjectType = stage1.ObjectType

	rcv.PermissionIdentifier = stage1.PermissionIdentifier

	rcv.PermissionName = stage1.PermissionName

	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "ObjectType")

	delete(stage2, "PermissionIdentifier")

	delete(stage2, "PermissionName")

	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.IamPermissionReferenceAO0P0 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m IamPermissionReferenceAO0P0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// The concrete type of this complex type.
		//
		// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
		// ObjectType is optional.
		// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
		// are heterogeneous, i.e. the array can contain nested documents of different types.
		//
		//
		ObjectType string `json:"ObjectType,omitempty"`

		// MOID of the permission which user has access to.
		//
		// Read Only: true
		PermissionIdentifier string `json:"PermissionIdentifier,omitempty"`

		// Name of the permission which user has access to.
		//
		// Read Only: true
		PermissionName string `json:"PermissionName,omitempty"`
	}

	stage1.ObjectType = m.ObjectType

	stage1.PermissionIdentifier = m.PermissionIdentifier

	stage1.PermissionName = m.PermissionName

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.IamPermissionReferenceAO0P0) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.IamPermissionReferenceAO0P0)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this iam permission reference a o0 p0
func (m *IamPermissionReferenceAO0P0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *IamPermissionReferenceAO0P0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *IamPermissionReferenceAO0P0) UnmarshalBinary(b []byte) error {
	var res IamPermissionReferenceAO0P0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
