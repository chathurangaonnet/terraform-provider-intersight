// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// ConnectorURL Connector:Url
//
// The URL to proxy the request to.
//
// swagger:model connectorUrl
type ConnectorURL struct {
	ConnectorURLAO0P0
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ConnectorURL) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 ConnectorURLAO0P0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.ConnectorURLAO0P0 = aO0

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ConnectorURL) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(m.ConnectorURLAO0P0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this connector Url
func (m *ConnectorURL) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with ConnectorURLAO0P0
	if err := m.ConnectorURLAO0P0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ConnectorURL) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConnectorURL) UnmarshalBinary(b []byte) error {
	var res ConnectorURL
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ConnectorURLAO0P0 connector URL a o0 p0
// swagger:model ConnectorURLAO0P0
type ConnectorURLAO0P0 struct {

	// Flag to append a query to the url even if rawQuery is empty.
	//
	ForceQuery *bool `json:"ForceQuery,omitempty"`

	// The fragment identifier component of a URI allows indirect identification of a secondary resource by reference to a primary resource and additional identifying information. The identified secondary resource may be some portion or subset of the primary resource, some view on representations of the primary resource, or some other resource defined or described by those representations. A fragment identifier component is indicated by the presence of a number sign ("#") character and terminated by the end of the URI.
	//
	//
	Fragment string `json:"Fragment,omitempty"`

	// The host name identifies the host that holds the resource. The host can be an IP or a hostname that is resolvable by the dns server configured on the platform.
	//
	Host string `json:"Host,omitempty"`

	// The concrete type of this complex type.
	//
	// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
	// ObjectType is optional.
	// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
	// are heterogeneous, i.e. the array can contain nested documents of different types.
	//
	//
	ObjectType string `json:"ObjectType,omitempty"`

	// A URI is opaque if, and only if, it is absolute and its scheme-specific part does not begin with a slash character ('/'). An opaque URI has a scheme, a scheme-specific part, and possibly a fragment; all other components are undefined.
	//
	Opaque string `json:"Opaque,omitempty"`

	// The path identifies the specific resource in the host that the web client wants to access. Value is the decoded form of the path. e.g. '/foo/bar'.
	//
	Path string `json:"Path,omitempty"`

	// The URI encoded form of the path property. e.g. '%2Fapi%2Fv1%2F'.
	//
	RawPath string `json:"RawPath,omitempty"`

	// The query component, as defined in RFC 3986, contains non-hierarchical data that, along with data in the path component, serves to identify a resource within the scope of the URI's scheme and naming authority (if any). The query component is indicated by the first question mark character and terminated by a number sign character or by the end of the URI.
	// The rawQuery contains the URIs encoded query component, excluding the ? character.
	//
	//
	RawQuery string `json:"RawQuery,omitempty"`

	// The scheme identifies the protocol to be used to access the resource on the Internet. It can be HTTP (without SSL) or HTTPS (with SSL).
	//
	Scheme string `json:"Scheme,omitempty"`

	// connector URL a o0 p0
	ConnectorURLAO0P0 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *ConnectorURLAO0P0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// Flag to append a query to the url even if rawQuery is empty.
		//
		ForceQuery *bool `json:"ForceQuery,omitempty"`

		// The fragment identifier component of a URI allows indirect identification of a secondary resource by reference to a primary resource and additional identifying information. The identified secondary resource may be some portion or subset of the primary resource, some view on representations of the primary resource, or some other resource defined or described by those representations. A fragment identifier component is indicated by the presence of a number sign ("#") character and terminated by the end of the URI.
		//
		//
		Fragment string `json:"Fragment,omitempty"`

		// The host name identifies the host that holds the resource. The host can be an IP or a hostname that is resolvable by the dns server configured on the platform.
		//
		Host string `json:"Host,omitempty"`

		// The concrete type of this complex type.
		//
		// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
		// ObjectType is optional.
		// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
		// are heterogeneous, i.e. the array can contain nested documents of different types.
		//
		//
		ObjectType string `json:"ObjectType,omitempty"`

		// A URI is opaque if, and only if, it is absolute and its scheme-specific part does not begin with a slash character ('/'). An opaque URI has a scheme, a scheme-specific part, and possibly a fragment; all other components are undefined.
		//
		Opaque string `json:"Opaque,omitempty"`

		// The path identifies the specific resource in the host that the web client wants to access. Value is the decoded form of the path. e.g. '/foo/bar'.
		//
		Path string `json:"Path,omitempty"`

		// The URI encoded form of the path property. e.g. '%2Fapi%2Fv1%2F'.
		//
		RawPath string `json:"RawPath,omitempty"`

		// The query component, as defined in RFC 3986, contains non-hierarchical data that, along with data in the path component, serves to identify a resource within the scope of the URI's scheme and naming authority (if any). The query component is indicated by the first question mark character and terminated by a number sign character or by the end of the URI.
		// The rawQuery contains the URIs encoded query component, excluding the ? character.
		//
		//
		RawQuery string `json:"RawQuery,omitempty"`

		// The scheme identifies the protocol to be used to access the resource on the Internet. It can be HTTP (without SSL) or HTTPS (with SSL).
		//
		Scheme string `json:"Scheme,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv ConnectorURLAO0P0

	rcv.ForceQuery = stage1.ForceQuery

	rcv.Fragment = stage1.Fragment

	rcv.Host = stage1.Host

	rcv.ObjectType = stage1.ObjectType

	rcv.Opaque = stage1.Opaque

	rcv.Path = stage1.Path

	rcv.RawPath = stage1.RawPath

	rcv.RawQuery = stage1.RawQuery

	rcv.Scheme = stage1.Scheme

	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "ForceQuery")

	delete(stage2, "Fragment")

	delete(stage2, "Host")

	delete(stage2, "ObjectType")

	delete(stage2, "Opaque")

	delete(stage2, "Path")

	delete(stage2, "RawPath")

	delete(stage2, "RawQuery")

	delete(stage2, "Scheme")

	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.ConnectorURLAO0P0 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m ConnectorURLAO0P0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// Flag to append a query to the url even if rawQuery is empty.
		//
		ForceQuery *bool `json:"ForceQuery,omitempty"`

		// The fragment identifier component of a URI allows indirect identification of a secondary resource by reference to a primary resource and additional identifying information. The identified secondary resource may be some portion or subset of the primary resource, some view on representations of the primary resource, or some other resource defined or described by those representations. A fragment identifier component is indicated by the presence of a number sign ("#") character and terminated by the end of the URI.
		//
		//
		Fragment string `json:"Fragment,omitempty"`

		// The host name identifies the host that holds the resource. The host can be an IP or a hostname that is resolvable by the dns server configured on the platform.
		//
		Host string `json:"Host,omitempty"`

		// The concrete type of this complex type.
		//
		// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
		// ObjectType is optional.
		// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
		// are heterogeneous, i.e. the array can contain nested documents of different types.
		//
		//
		ObjectType string `json:"ObjectType,omitempty"`

		// A URI is opaque if, and only if, it is absolute and its scheme-specific part does not begin with a slash character ('/'). An opaque URI has a scheme, a scheme-specific part, and possibly a fragment; all other components are undefined.
		//
		Opaque string `json:"Opaque,omitempty"`

		// The path identifies the specific resource in the host that the web client wants to access. Value is the decoded form of the path. e.g. '/foo/bar'.
		//
		Path string `json:"Path,omitempty"`

		// The URI encoded form of the path property. e.g. '%2Fapi%2Fv1%2F'.
		//
		RawPath string `json:"RawPath,omitempty"`

		// The query component, as defined in RFC 3986, contains non-hierarchical data that, along with data in the path component, serves to identify a resource within the scope of the URI's scheme and naming authority (if any). The query component is indicated by the first question mark character and terminated by a number sign character or by the end of the URI.
		// The rawQuery contains the URIs encoded query component, excluding the ? character.
		//
		//
		RawQuery string `json:"RawQuery,omitempty"`

		// The scheme identifies the protocol to be used to access the resource on the Internet. It can be HTTP (without SSL) or HTTPS (with SSL).
		//
		Scheme string `json:"Scheme,omitempty"`
	}

	stage1.ForceQuery = m.ForceQuery

	stage1.Fragment = m.Fragment

	stage1.Host = m.Host

	stage1.ObjectType = m.ObjectType

	stage1.Opaque = m.Opaque

	stage1.Path = m.Path

	stage1.RawPath = m.RawPath

	stage1.RawQuery = m.RawQuery

	stage1.Scheme = m.Scheme

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.ConnectorURLAO0P0) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.ConnectorURLAO0P0)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this connector URL a o0 p0
func (m *ConnectorURLAO0P0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ConnectorURLAO0P0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConnectorURLAO0P0) UnmarshalBinary(b []byte) error {
	var res ConnectorURLAO0P0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
