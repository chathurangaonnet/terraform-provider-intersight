// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AssetConnectionControlMessage Asset:Connection Control Message
//
// Control message used to update the context of a devices connection. When a device registration is modified (e.g. by a user modifying the claim status) the process managing the connection must be notified of the change. On changes aurora will attempt to send the change to the current owner of the connection.
//
// swagger:model assetConnectionControlMessage
type AssetConnectionControlMessage struct {
	AssetConnectionControlMessageAO0P0
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *AssetConnectionControlMessage) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 AssetConnectionControlMessageAO0P0
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.AssetConnectionControlMessageAO0P0 = aO0

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m AssetConnectionControlMessage) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	aO0, err := swag.WriteJSON(m.AssetConnectionControlMessageAO0P0)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this asset connection control message
func (m *AssetConnectionControlMessage) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with AssetConnectionControlMessageAO0P0
	if err := m.AssetConnectionControlMessageAO0P0.Validate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *AssetConnectionControlMessage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetConnectionControlMessage) UnmarshalBinary(b []byte) error {
	var res AssetConnectionControlMessage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// AssetConnectionControlMessageAO0P0 asset connection control message a o0 p0
// swagger:model AssetConnectionControlMessageAO0P0
type AssetConnectionControlMessageAO0P0 struct {

	// The account id to which the device belongs.
	//
	Account string `json:"Account,omitempty"`

	// The version of the device connector currently running on the platform. Deprecated by newer connectors that will report this directly to the device connector gateway in a websocket header, but included to continue to support older versions which report any version change after connect.
	//
	ConnectorVersion string `json:"ConnectorVersion,omitempty"`

	// The Moid of the device under change. Used to route the message to a devices connection.
	//
	DeviceID string `json:"DeviceId,omitempty"`

	// The domain group id to which the device belongs.
	//
	DomainGroup string `json:"DomainGroup,omitempty"`

	// Flag to force any open connections to be evicted. Used in case device has been deleted or blacklisted.
	//
	Evict *bool `json:"Evict,omitempty"`

	// The current leadership of a device cluster member.
	//
	// Enum: [Unknown Primary Secondary]
	Leadership *string `json:"Leadership,omitempty"`

	// The new identity assigned to a device on ownership change (claim/unclaim).
	//
	NewIdentity string `json:"NewIdentity,omitempty"`

	// The concrete type of this complex type.
	//
	// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
	// ObjectType is optional.
	// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
	// are heterogeneous, i.e. the array can contain nested documents of different types.
	//
	//
	ObjectType string `json:"ObjectType,omitempty"`

	// The partition the device was last connected to, used to address the control message to the device connector gateway instance holding the devices connection.
	//
	Partition int64 `json:"Partition,omitempty"`

	// asset connection control message a o0 p0
	AssetConnectionControlMessageAO0P0 map[string]interface{} `json:"-"`
}

// UnmarshalJSON unmarshals this object with additional properties from JSON
func (m *AssetConnectionControlMessageAO0P0) UnmarshalJSON(data []byte) error {
	// stage 1, bind the properties
	var stage1 struct {

		// The account id to which the device belongs.
		//
		Account string `json:"Account,omitempty"`

		// The version of the device connector currently running on the platform. Deprecated by newer connectors that will report this directly to the device connector gateway in a websocket header, but included to continue to support older versions which report any version change after connect.
		//
		ConnectorVersion string `json:"ConnectorVersion,omitempty"`

		// The Moid of the device under change. Used to route the message to a devices connection.
		//
		DeviceID string `json:"DeviceId,omitempty"`

		// The domain group id to which the device belongs.
		//
		DomainGroup string `json:"DomainGroup,omitempty"`

		// Flag to force any open connections to be evicted. Used in case device has been deleted or blacklisted.
		//
		Evict *bool `json:"Evict,omitempty"`

		// The current leadership of a device cluster member.
		//
		// Enum: [Unknown Primary Secondary]
		Leadership *string `json:"Leadership,omitempty"`

		// The new identity assigned to a device on ownership change (claim/unclaim).
		//
		NewIdentity string `json:"NewIdentity,omitempty"`

		// The concrete type of this complex type.
		//
		// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
		// ObjectType is optional.
		// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
		// are heterogeneous, i.e. the array can contain nested documents of different types.
		//
		//
		ObjectType string `json:"ObjectType,omitempty"`

		// The partition the device was last connected to, used to address the control message to the device connector gateway instance holding the devices connection.
		//
		Partition int64 `json:"Partition,omitempty"`
	}
	if err := json.Unmarshal(data, &stage1); err != nil {
		return err
	}
	var rcv AssetConnectionControlMessageAO0P0

	rcv.Account = stage1.Account

	rcv.ConnectorVersion = stage1.ConnectorVersion

	rcv.DeviceID = stage1.DeviceID

	rcv.DomainGroup = stage1.DomainGroup

	rcv.Evict = stage1.Evict

	rcv.Leadership = stage1.Leadership

	rcv.NewIdentity = stage1.NewIdentity

	rcv.ObjectType = stage1.ObjectType

	rcv.Partition = stage1.Partition

	*m = rcv

	// stage 2, remove properties and add to map
	stage2 := make(map[string]json.RawMessage)
	if err := json.Unmarshal(data, &stage2); err != nil {
		return err
	}

	delete(stage2, "Account")

	delete(stage2, "ConnectorVersion")

	delete(stage2, "DeviceId")

	delete(stage2, "DomainGroup")

	delete(stage2, "Evict")

	delete(stage2, "Leadership")

	delete(stage2, "NewIdentity")

	delete(stage2, "ObjectType")

	delete(stage2, "Partition")

	// stage 3, add additional properties values
	if len(stage2) > 0 {
		result := make(map[string]interface{})
		for k, v := range stage2 {
			var toadd interface{}
			if err := json.Unmarshal(v, &toadd); err != nil {
				return err
			}
			result[k] = toadd
		}
		m.AssetConnectionControlMessageAO0P0 = result
	}

	return nil
}

// MarshalJSON marshals this object with additional properties into a JSON object
func (m AssetConnectionControlMessageAO0P0) MarshalJSON() ([]byte, error) {
	var stage1 struct {

		// The account id to which the device belongs.
		//
		Account string `json:"Account,omitempty"`

		// The version of the device connector currently running on the platform. Deprecated by newer connectors that will report this directly to the device connector gateway in a websocket header, but included to continue to support older versions which report any version change after connect.
		//
		ConnectorVersion string `json:"ConnectorVersion,omitempty"`

		// The Moid of the device under change. Used to route the message to a devices connection.
		//
		DeviceID string `json:"DeviceId,omitempty"`

		// The domain group id to which the device belongs.
		//
		DomainGroup string `json:"DomainGroup,omitempty"`

		// Flag to force any open connections to be evicted. Used in case device has been deleted or blacklisted.
		//
		Evict *bool `json:"Evict,omitempty"`

		// The current leadership of a device cluster member.
		//
		// Enum: [Unknown Primary Secondary]
		Leadership *string `json:"Leadership,omitempty"`

		// The new identity assigned to a device on ownership change (claim/unclaim).
		//
		NewIdentity string `json:"NewIdentity,omitempty"`

		// The concrete type of this complex type.
		//
		// The ObjectType property must be set explicitly by API clients when the type is ambiguous. In all other cases, the
		// ObjectType is optional.
		// The type is ambiguous when a managed object contains an array of nested documents, and the documents in the array
		// are heterogeneous, i.e. the array can contain nested documents of different types.
		//
		//
		ObjectType string `json:"ObjectType,omitempty"`

		// The partition the device was last connected to, used to address the control message to the device connector gateway instance holding the devices connection.
		//
		Partition int64 `json:"Partition,omitempty"`
	}

	stage1.Account = m.Account

	stage1.ConnectorVersion = m.ConnectorVersion

	stage1.DeviceID = m.DeviceID

	stage1.DomainGroup = m.DomainGroup

	stage1.Evict = m.Evict

	stage1.Leadership = m.Leadership

	stage1.NewIdentity = m.NewIdentity

	stage1.ObjectType = m.ObjectType

	stage1.Partition = m.Partition

	// make JSON object for known properties
	props, err := json.Marshal(stage1)
	if err != nil {
		return nil, err
	}

	if len(m.AssetConnectionControlMessageAO0P0) == 0 {
		return props, nil
	}

	// make JSON object for the additional properties
	additional, err := json.Marshal(m.AssetConnectionControlMessageAO0P0)
	if err != nil {
		return nil, err
	}

	if len(props) < 3 {
		return additional, nil
	}

	// concatenate the 2 objects
	props[len(props)-1] = ','
	return append(props, additional[1:]...), nil
}

// Validate validates this asset connection control message a o0 p0
func (m *AssetConnectionControlMessageAO0P0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLeadership(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var assetConnectionControlMessageAO0P0TypeLeadershipPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Unknown","Primary","Secondary"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		assetConnectionControlMessageAO0P0TypeLeadershipPropEnum = append(assetConnectionControlMessageAO0P0TypeLeadershipPropEnum, v)
	}
}

const (

	// AssetConnectionControlMessageAO0P0LeadershipUnknown captures enum value "Unknown"
	AssetConnectionControlMessageAO0P0LeadershipUnknown string = "Unknown"

	// AssetConnectionControlMessageAO0P0LeadershipPrimary captures enum value "Primary"
	AssetConnectionControlMessageAO0P0LeadershipPrimary string = "Primary"

	// AssetConnectionControlMessageAO0P0LeadershipSecondary captures enum value "Secondary"
	AssetConnectionControlMessageAO0P0LeadershipSecondary string = "Secondary"
)

// prop value enum
func (m *AssetConnectionControlMessageAO0P0) validateLeadershipEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, assetConnectionControlMessageAO0P0TypeLeadershipPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *AssetConnectionControlMessageAO0P0) validateLeadership(formats strfmt.Registry) error {

	if swag.IsZero(m.Leadership) { // not required
		return nil
	}

	// value enum
	if err := m.validateLeadershipEnum("Leadership", "body", *m.Leadership); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AssetConnectionControlMessageAO0P0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AssetConnectionControlMessageAO0P0) UnmarshalBinary(b []byte) error {
	var res AssetConnectionControlMessageAO0P0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
